41. 缺失的第一个正数

给你一个未排序的整数数组 nums ，请你找出其中没有出现的最小的正整数。
进阶：你可以实现时间复杂度为 O(n) 并且只使用常数级别额外空间的解决方案吗？
示例 1：

	输入：nums = [1,2,0]
	输出：3
示例 2：

	输入：nums = [3,4,-1,1]
	输出：2
示例 3：

	输入：nums = [7,8,9,11,12]
	输出：1
 
提示：

	0 <= nums.length <= 300
	-231 <= nums[i] <= 231 - 1
--------------解题思路----------------------------------------------------------------------------
使用数组arr，将数组全部置0，将数组中的数对应的置为1，，将数组全部置0，将数组中的数对应的置为1，
然后将数组arr第一个为0 的下标输出。

注：如果遇到大于数组下标或者小于等于0的数字跳过
	
--------------代码---------------------------------------------------------------------------------	
class Solution {
    public int firstMissingPositive(int[] nums) {
        if(nums.length == 0){
            return 1;
        }
        int[]  arr = new int[nums.length + 1];
        for(int num : nums){
            if(num > nums.length || num <= 0){
                continue;
            }
            arr[num] = 1;
        }
        for(int i = 1;i < arr.length; i++){
            if(arr[i] == 0){
                return i;
            }
        }
        return nums.length + 1;
    }
}






